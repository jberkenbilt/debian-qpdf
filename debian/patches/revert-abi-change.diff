Index: qpdf-4.2.0/ChangeLog
===================================================================
--- qpdf-4.2.0.orig/ChangeLog	2013-07-10 12:59:45.339053938 -0400
+++ qpdf-4.2.0/ChangeLog	2013-07-10 12:59:45.323053938 -0400
@@ -32,12 +32,6 @@
 	This key is optional, but some version of MacOS reportedly fail to
 	open encrypted PDF files without this key.
 
-	* Bug fix: properly handle object stream generation when the
-	original file has some compressible objects with generation != 0.
-
-	* Add QPDF::getCompressibleObjGens() and deprecate
-	QPDF::getCompressibleObjects(), which had a flaw in its logic.
-
 	* Add new QPDFObjectHandle::getObjGen() method and indiciate in
 	comments that its use is favored over getObjectID() and
 	getGeneration() for most cases.
Index: qpdf-4.2.0/include/qpdf/QPDF.hh
===================================================================
--- qpdf-4.2.0.orig/include/qpdf/QPDF.hh	2013-07-10 12:59:45.339053938 -0400
+++ qpdf-4.2.0/include/qpdf/QPDF.hh	2013-07-10 12:59:45.323053938 -0400
@@ -434,19 +434,8 @@
     // Map object to object stream that contains it
     QPDF_DLL
     void getObjectStreamData(std::map<int, int>&);
-
     // Get a list of objects that would be permitted in an object
-    // stream.
-    QPDF_DLL
-    std::vector<QPDFObjGen> getCompressibleObjGens();
-
-    // Deprecated: get a list of objects that would be permitted in an
-    // object stream.  This method is deprecated and will be removed.
-    // It's incorrect because it disregards the generations of the
-    // compressible objects, which can lead (and has lead) to bugs.
-    // This method will throw an exception if any of the objects
-    // returned have a generation of other than zero.  Use
-    // getCompressibleObjGens() instead.
+    // stream
     QPDF_DLL
     std::vector<int> getCompressibleObjects();
 
Index: qpdf-4.2.0/include/qpdf/QPDFWriter.hh
===================================================================
--- qpdf-4.2.0.orig/include/qpdf/QPDFWriter.hh	2013-07-10 12:59:45.339053938 -0400
+++ qpdf-4.2.0/include/qpdf/QPDFWriter.hh	2013-07-10 12:59:45.323053938 -0400
@@ -24,7 +24,6 @@
 
 #include <qpdf/Constants.h>
 
-#include <qpdf/QPDFObjGen.hh>
 #include <qpdf/QPDFXRefEntry.hh>
 
 #include <qpdf/Pl_Buffer.hh>
@@ -290,7 +289,7 @@
     void writeStringQDF(std::string const& str);
     void writeStringNoQDF(std::string const& str);
     void writePad(int nspaces);
-    void assignCompressedObjectNumbers(QPDFObjGen const& og);
+    void assignCompressedObjectNumbers(int objid);
     void enqueueObject(QPDFObjectHandle object);
     void writeObjectStreamOffsets(
         std::vector<qpdf_offset_t>& offsets, int first_obj);
@@ -381,9 +380,6 @@
     void pushEncryptionFilter();
     void pushDiscardFilter();
 
-    void discardGeneration(std::map<QPDFObjGen, int> const& in,
-                           std::map<int, int>& out);
-
     QPDF& pdf;
     char const* filename;
     FILE* file;
@@ -423,7 +419,7 @@
     std::list<PointerHolder<Pipeline> > to_delete;
     Pl_Count* pipeline;
     std::list<QPDFObjectHandle> object_queue;
-    std::map<QPDFObjGen, int> obj_renumber;
+    std::map<int, int> obj_renumber;
     std::map<int, QPDFXRefEntry> xref;
     std::map<int, qpdf_offset_t> lengths;
     int next_objid;
@@ -431,16 +427,12 @@
     size_t cur_stream_length;
     bool added_newline;
     int max_ostream_index;
-    std::set<QPDFObjGen> normalized_streams;
-    std::map<QPDFObjGen, int> page_object_to_seq;
-    std::map<QPDFObjGen, int> contents_to_page_seq;
-    std::map<QPDFObjGen, int> object_to_object_stream;
-    std::map<int, std::set<QPDFObjGen> > object_stream_to_objects;
+    std::set<int> normalized_streams;
+    std::map<int, int> page_object_to_seq;
+    std::map<int, int> contents_to_page_seq;
+    std::map<int, int> object_to_object_stream;
+    std::map<int, std::set<int> > object_stream_to_objects;
     std::list<Pipeline*> pipeline_stack;
-
-    // For linearization only
-    std::map<int, int> obj_renumber_no_gen;
-    std::map<int, int> object_to_object_stream_no_gen;
 };
 
 #endif // __QPDFWRITER_HH__
Index: qpdf-4.2.0/libqpdf/QPDF.cc
===================================================================
--- qpdf-4.2.0.orig/libqpdf/QPDF.cc	2013-07-10 12:59:45.339053938 -0400
+++ qpdf-4.2.0/libqpdf/QPDF.cc	2013-07-10 12:59:45.323053938 -0400
@@ -1955,68 +1955,55 @@
 std::vector<int>
 QPDF::getCompressibleObjects()
 {
-    std::vector<QPDFObjGen> objects = getCompressibleObjGens();
-    std::vector<int> result;
-    for (std::vector<QPDFObjGen>::iterator iter = objects.begin();
-         iter != objects.end(); ++iter)
-    {
-        if ((*iter).getGen() != 0)
-        {
-            throw std::logic_error(
-                "QPDF::getCompressibleObjects() would return an object ID"
-                " for an object with generation != 0.  Use"
-                " QPDF::getCompressibleObjGens() instead."
-                "  See comments in QPDF.hh.");
-        }
-        else
-        {
-            result.push_back((*iter).getObj());
-        }
-    }
-    return result;
-}
+    // Return a set of object numbers of objects that are allowed to
+    // be in object streams.  We disregard generation numbers here
+    // since this is a helper function for QPDFWriter which is going
+    // to renumber objects anyway.  This code will do weird things if
+    // we have two objects with the same object number and different
+    // generations, but so do virtually all PDF consumers,
+    // particularly since this is not a permitted condition.
 
-std::vector<QPDFObjGen>
-QPDF::getCompressibleObjGens()
-{
-    // Return a list of objects that are allowed to be in object
-    // streams.  Walk through the objects by traversing the document
-    // from the root, including a traversal of the pages tree.  This
-    // makes that objects that are on the same page are more likely to
-    // be in the same object stream, which is slightly more efficient,
+    // We walk through the objects by traversing the document from the
+    // root, including a traversal of the pages tree.  This makes that
+    // objects that are on the same page are more likely to be in the
+    // same object stream, which is slightly more efficient,
     // particularly with linearized files.  This is better than
     // iterating through the xref table since it avoids preserving
     // orphaned items.
 
     // Exclude encryption dictionary, if any
+    int encryption_dict_id = 0;
     QPDFObjectHandle encryption_dict = trailer.getKey("/Encrypt");
-    QPDFObjGen encryption_dict_og = encryption_dict.getObjGen();
+    if (encryption_dict.isIndirect())
+    {
+	encryption_dict_id = encryption_dict.getObjectID();
+    }
 
-    std::set<QPDFObjGen> visited;
+    std::set<int> visited;
     std::list<QPDFObjectHandle> queue;
     queue.push_front(this->trailer);
-    std::vector<QPDFObjGen> result;
+    std::vector<int> result;
     while (! queue.empty())
     {
 	QPDFObjectHandle obj = queue.front();
 	queue.pop_front();
 	if (obj.isIndirect())
 	{
-	    QPDFObjGen og = obj.getObjGen();
-	    if (visited.count(og))
+	    int objid = obj.getObjectID();
+	    if (visited.count(objid))
 	    {
 		QTC::TC("qpdf", "QPDF loop detected traversing objects");
 		continue;
 	    }
-	    if (og == encryption_dict_og)
+	    if (objid == encryption_dict_id)
 	    {
 		QTC::TC("qpdf", "QPDF exclude encryption dictionary");
 	    }
 	    else if (! obj.isStream())
 	    {
-		result.push_back(og);
+		result.push_back(objid);
 	    }
-	    visited.insert(og);
+	    visited.insert(objid);
 	}
 	if (obj.isStream())
 	{
Index: qpdf-4.2.0/libqpdf/QPDFWriter.cc
===================================================================
--- qpdf-4.2.0.orig/libqpdf/QPDFWriter.cc	2013-07-10 12:59:45.339053938 -0400
+++ qpdf-4.2.0/libqpdf/QPDFWriter.cc	2013-07-10 12:59:45.327053938 -0400
@@ -938,19 +938,16 @@
 }
 
 void
-QPDFWriter::assignCompressedObjectNumbers(QPDFObjGen const& og)
+QPDFWriter::assignCompressedObjectNumbers(int objid)
 {
-    int objid = og.getObj();
-    if ((og.getGen() != 0) ||
-        (this->object_stream_to_objects.count(objid) == 0))
+    if (this->object_stream_to_objects.count(objid) == 0)
     {
-        // This is not an object stream.
 	return;
     }
 
     // Reserve numbers for the objects that belong to this object
     // stream.
-    for (std::set<QPDFObjGen>::iterator iter =
+    for (std::set<int>::iterator iter =
 	     this->object_stream_to_objects[objid].begin();
 	 iter != this->object_stream_to_objects[objid].end();
 	 ++iter)
@@ -977,32 +974,30 @@
 	{
 	    // This is a place-holder object for an object stream
 	}
-	QPDFObjGen og = object.getObjGen();
+	int objid = object.getObjectID();
 
-	if (obj_renumber.count(og) == 0)
+	if (obj_renumber.count(objid) == 0)
 	{
-	    if (this->object_to_object_stream.count(og))
+	    if (this->object_to_object_stream.count(objid))
 	    {
 		// This is in an object stream.  Don't process it
-		// here.  Instead, enqueue the object stream.  Object
-		// streams always have generation 0.
-		int stream_id = this->object_to_object_stream[og];
+		// here.  Instead, enqueue the object stream.
+		int stream_id = this->object_to_object_stream[objid];
 		enqueueObject(this->pdf.getObjectByID(stream_id, 0));
 	    }
 	    else
 	    {
 		object_queue.push_back(object);
-		obj_renumber[og] = next_objid++;
+		obj_renumber[objid] = next_objid++;
 
-		if ((og.getGen() == 0) &&
-                    this->object_stream_to_objects.count(og.getObj()))
+		if (this->object_stream_to_objects.count(objid))
 		{
 		    // For linearized files, uncompressed objects go
 		    // at end, and we take care of assigning numbers
 		    // to them elsewhere.
 		    if (! this->linearized)
 		    {
-			assignCompressedObjectNumbers(og);
+			assignCompressedObjectNumbers(objid);
 		    }
 		}
 		else if ((! this->direct_stream_lengths) && object.isStream())
@@ -1051,8 +1046,8 @@
     }
     if (child.isIndirect())
     {
-	QPDFObjGen old_og = child.getObjGen();
-	int new_id = obj_renumber[old_og];
+	int old_id = child.getObjectID();
+	int new_id = obj_renumber[old_id];
 	writeString(QUtil::int_to_string(new_id));
 	writeString(" 0 R");
     }
@@ -1144,7 +1139,7 @@
 			  unsigned int flags, size_t stream_length,
                           bool compress)
 {
-    QPDFObjGen old_og = object.getObjGen();
+    int old_id = object.getObjectID();
     unsigned int child_flags = flags & ~f_stream;
 
     std::string indent;
@@ -1211,7 +1206,7 @@
         bool have_extensions_adbe = false;
 
         QPDFObjectHandle extensions;
-        if (old_og == pdf.getRoot().getObjGen())
+        if (old_id == pdf.getRoot().getObjectID())
         {
             is_root = true;
             if (object.hasKey("/Extensions") &&
@@ -1406,7 +1401,7 @@
     else if (object.isStream())
     {
 	// Write stream data to a buffer.
-	int new_id = obj_renumber[old_og];
+	int new_id = obj_renumber[old_id];
 	if (! this->direct_stream_lengths)
 	{
 	    this->cur_stream_length_id = new_id + 1;
@@ -1446,7 +1441,7 @@
 	    filter = true;
 	    compress = false;
 	}
-	else if (this->normalize_content && normalized_streams.count(old_og))
+	else if (this->normalize_content && normalized_streams.count(old_id))
 	{
 	    normalize = true;
 	    filter = true;
@@ -1572,10 +1567,8 @@
     // Note: object might be null if this is a place-holder for an
     // object stream that we are generating from scratch.
 
-    QPDFObjGen old_og = object.getObjGen();
-    assert(old_og.getGen() == 0);
-    int old_id = old_og.getObj();
-    int new_id = obj_renumber[old_og];
+    int old_id = object.getObjectID();
+    int new_id = obj_renumber[old_id];
 
     std::vector<qpdf_offset_t> offsets;
     qpdf_offset_t first = 0;
@@ -1624,12 +1617,12 @@
 	}
 
 	int count = 0;
-	for (std::set<QPDFObjGen>::iterator iter =
+	for (std::set<int>::iterator iter =
 		 this->object_stream_to_objects[old_id].begin();
 	     iter != this->object_stream_to_objects[old_id].end();
 	     ++iter, ++count)
 	{
-	    QPDFObjGen obj = *iter;
+	    int obj = *iter;
 	    int new_obj = this->obj_renumber[obj];
 	    if (first_obj == -1)
 	    {
@@ -1643,17 +1636,7 @@
 		if (! this->suppress_original_object_ids)
 		{
 		    writeString("; original object ID: " +
-				QUtil::int_to_string(obj.getObj()));
-                    // For compatibility, only write the generation if
-                    // non-zero.  While object streams only allow
-                    // objects with generation 0, if we are generating
-                    // object streams, the old object could have a
-                    // non-zero generation.
-                    if (obj.getGen() != 0)
-                    {
-                        QTC::TC("qpdf", "QPDFWriter original obj non-zero gen");
-                        writeString(" " + QUtil::int_to_string(obj.getGen()));
-                    }
+				QUtil::int_to_string(obj));
 		}
 		writeString("\n");
 	    }
@@ -1661,7 +1644,7 @@
 	    {
 		offsets.push_back(this->pipeline->getCount());
 	    }
-	    writeObject(this->pdf.getObjectByObjGen(obj), count);
+	    writeObject(this->pdf.getObjectByID(obj, 0), count);
 
 	    this->xref[new_obj] = QPDFXRefEntry(2, new_id, count);
 	}
@@ -1719,33 +1702,32 @@
 void
 QPDFWriter::writeObject(QPDFObjectHandle object, int object_stream_index)
 {
-    QPDFObjGen old_og = object.getObjGen();
+    int old_id = object.getObjectID();
 
     if ((object_stream_index == -1) &&
-        (old_og.getGen() == 0) &&
-	(this->object_stream_to_objects.count(old_og.getObj())))
+	(this->object_stream_to_objects.count(old_id)))
     {
 	writeObjectStream(object);
 	return;
     }
 
-    int new_id = obj_renumber[old_og];
+    int new_id = obj_renumber[old_id];
     if (this->qdf_mode)
     {
-	if (this->page_object_to_seq.count(old_og))
+	if (this->page_object_to_seq.count(old_id))
 	{
 	    writeString("%% Page ");
 	    writeString(
 		QUtil::int_to_string(
-		    this->page_object_to_seq[old_og]));
+		    this->page_object_to_seq[old_id]));
 	    writeString("\n");
 	}
-	if (this->contents_to_page_seq.count(old_og))
+	if (this->contents_to_page_seq.count(old_id))
 	{
 	    writeString("%% Contents for page ");
 	    writeString(
 		QUtil::int_to_string(
-		    this->contents_to_page_seq[old_og]));
+		    this->contents_to_page_seq[old_id]));
 	    writeString("\n");
 	}
     }
@@ -1877,24 +1859,24 @@
 	 iter != pages.end(); ++iter)
     {
 	QPDFObjectHandle& page = *iter;
-	this->page_object_to_seq[page.getObjGen()] = ++num;
+	this->page_object_to_seq[page.getObjectID()] = ++num;
 	QPDFObjectHandle contents = page.getKey("/Contents");
-	std::vector<QPDFObjGen> contents_objects;
+	std::vector<int> contents_objects;
 	if (contents.isArray())
 	{
 	    int n = contents.getArrayNItems();
 	    for (int i = 0; i < n; ++i)
 	    {
 		contents_objects.push_back(
-		    contents.getArrayItem(i).getObjGen());
+		    contents.getArrayItem(i).getObjectID());
 	    }
 	}
 	else if (contents.isStream())
 	{
-	    contents_objects.push_back(contents.getObjGen());
+	    contents_objects.push_back(contents.getObjectID());
 	}
 
-	for (std::vector<QPDFObjGen>::iterator iter = contents_objects.begin();
+	for (std::vector<int>::iterator iter = contents_objects.begin();
 	     iter != contents_objects.end(); ++iter)
 	{
 	    this->contents_to_page_seq[*iter] = num;
@@ -1906,20 +1888,7 @@
 void
 QPDFWriter::preserveObjectStreams()
 {
-    // Our object_to_object_stream map has to map ObjGen -> ObjGen
-    // since we may be generating object streams out of old objects
-    // that have generation numbers greater than zero.  However in an
-    // existing PDF, all object stream objects and all objects in them
-    // must have generation 0 because the PDF spec does not provide
-    // any way to do otherwise.
-    std::map<int, int> omap;
-    this->pdf.getObjectStreamData(omap);
-    for (std::map<int, int>::iterator iter = omap.begin();
-         iter != omap.end(); ++iter)
-    {
-        this->object_to_object_stream[QPDFObjGen((*iter).first, 0)] =
-            (*iter).second;
-    }
+    this->pdf.getObjectStreamData(this->object_to_object_stream);
 }
 
 void
@@ -1935,8 +1904,7 @@
 
     // This code doesn't do anything with /Extends.
 
-    std::vector<QPDFObjGen> const& eligible =
-        this->pdf.getCompressibleObjGens();
+    std::vector<int> const& eligible = this->pdf.getCompressibleObjects();
     unsigned int n_object_streams = (eligible.size() + 99) / 100;
     unsigned int n_per = eligible.size() / n_object_streams;
     if (n_per * n_object_streams < eligible.size())
@@ -1945,7 +1913,7 @@
     }
     unsigned int n = 0;
     int cur_ostream = 0;
-    for (std::vector<QPDFObjGen>::const_iterator iter = eligible.begin();
+    for (std::vector<int>::const_iterator iter = eligible.begin();
 	 iter != eligible.end(); ++iter)
     {
 	if ((n % n_per) == 0)
@@ -2209,11 +2177,11 @@
 	     iter != pages.end(); ++iter)
 	{
 	    QPDFObjectHandle& page = *iter;
-	    QPDFObjGen og = page.getObjGen();
-	    if (this->object_to_object_stream.count(og))
+	    int objid = page.getObjectID();
+	    if (this->object_to_object_stream.count(objid))
 	    {
 		QTC::TC("qpdf", "QPDFWriter uncompressing page dictionary");
-		this->object_to_object_stream.erase(og);
+		this->object_to_object_stream.erase(objid);
 	    }
 	}
     }
@@ -2225,20 +2193,20 @@
     	// 8.0.0 has a bug that prevents it from being able to handle
     	// encrypted files with compressed document catalogs, so we
     	// disable them in that case as well.
-	QPDFObjGen og = pdf.getRoot().getObjGen();
-	if (this->object_to_object_stream.count(og))
+	int objid = pdf.getRoot().getObjectID();
+	if (this->object_to_object_stream.count(objid))
 	{
 	    QTC::TC("qpdf", "QPDFWriter uncompressing root");
-	    this->object_to_object_stream.erase(og);
+	    this->object_to_object_stream.erase(objid);
 	}
     }
 
     // Generate reverse mapping from object stream to objects
-    for (std::map<QPDFObjGen, int>::iterator iter =
+    for (std::map<int, int>::iterator iter =
 	     this->object_to_object_stream.begin();
 	 iter != this->object_to_object_stream.end(); ++iter)
     {
-	QPDFObjGen obj = (*iter).first;
+	int obj = (*iter).first;
 	int stream = (*iter).second;
 	this->object_stream_to_objects[stream].insert(obj);
 	this->max_ostream_index =
@@ -2340,8 +2308,7 @@
     int S = 0;
     int O = 0;
     pdf.generateHintStream(
-	this->xref, this->lengths, this->obj_renumber_no_gen,
-        hint_buffer, S, O);
+	this->xref, this->lengths, this->obj_renumber, hint_buffer, S, O);
 
     openObject(hint_id);
     setDataKey(hint_id);
@@ -2560,57 +2527,19 @@
 }
 
 void
-QPDFWriter::discardGeneration(std::map<QPDFObjGen, int> const& in,
-                              std::map<int, int>& out)
-{
-    // There are deep assumptions in the linearization code in QPDF
-    // that there is only one object with each object number; i.e.,
-    // you can't have two objects with the same object number and
-    // different generations.  This is a pretty safe assumption
-    // because Adobe Reader and Acrobat can't actually handle this
-    // case.  There is not much if any code in QPDF outside
-    // linearization that assumes this, but the linearization code as
-    // currently implemented would do weird things if we found such a
-    // case.  In order to avoid breaking ABI changes in QPDF, we will
-    // first assert that this condition holds.  Then we can create new
-    // maps for QPDF that throw away generation numbers.
-
-    out.clear();
-    for (std::map<QPDFObjGen, int>::const_iterator iter = in.begin();
-         iter != in.end(); ++iter)
-    {
-        if (out.count((*iter).first.getObj()))
-        {
-            throw std::logic_error(
-                "QPDF cannot currently linearize files that contain"
-                " multiple objects with the same object ID and different"
-                " generations.  If you see this error message, please file"
-                " a bug report and attach the file if possible.  As a"
-                " workaround, first convert the file with qpdf without"
-                " linearizing, and then linearize the result of that"
-                " conversion.");
-        }
-        out[(*iter).first.getObj()] = (*iter).second;
-    }
-}
-
-void
 QPDFWriter::writeLinearized()
 {
     // Optimize file and enqueue objects in order
 
-    discardGeneration(this->object_to_object_stream,
-                      this->object_to_object_stream_no_gen);
-
     bool need_xref_stream = (! this->object_to_object_stream.empty());
-    pdf.optimize(this->object_to_object_stream_no_gen);
+    pdf.optimize(this->object_to_object_stream);
 
     std::vector<QPDFObjectHandle> part4;
     std::vector<QPDFObjectHandle> part6;
     std::vector<QPDFObjectHandle> part7;
     std::vector<QPDFObjectHandle> part8;
     std::vector<QPDFObjectHandle> part9;
-    pdf.getLinearizedParts(this->object_to_object_stream_no_gen,
+    pdf.getLinearizedParts(this->object_to_object_stream,
 			   part4, part6, part7, part8, part9);
 
     // Object number sequence:
@@ -2646,7 +2575,7 @@
 	for (std::vector<QPDFObjectHandle>::iterator iter = (*vecs2[i]).begin();
 	     iter != (*vecs2[i]).end(); ++iter)
 	{
-	    assignCompressedObjectNumbers((*iter).getObjGen());
+	    assignCompressedObjectNumbers((*iter).getObjectID());
 	}
     }
     int second_half_end = this->next_objid - 1;
@@ -2678,7 +2607,7 @@
 	for (std::vector<QPDFObjectHandle>::iterator iter = (*vecs1[i]).begin();
 	     iter != (*vecs1[i]).end(); ++iter)
 	{
-	    assignCompressedObjectNumbers((*iter).getObjGen());
+	    assignCompressedObjectNumbers((*iter).getObjectID());
 	}
     }
     int first_half_end = this->next_objid - 1;
@@ -2736,7 +2665,7 @@
 	if (pass == 2)
 	{
 	    std::vector<QPDFObjectHandle> const& pages = pdf.getAllPages();
-	    int first_page_object = obj_renumber[pages[0].getObjGen()];
+	    int first_page_object = obj_renumber[pages[0].getObjectID()];
 	    int npages = pages.size();
 
 	    writeString(" /Linearized 1 /L ");
@@ -2910,8 +2839,6 @@
 	writeString(QUtil::int_to_string(first_xref_offset));
 	writeString("\n%%EOF\n");
 
-        discardGeneration(this->obj_renumber, this->obj_renumber_no_gen);
-
 	if (pass == 1)
 	{
 	    // Close first pass pipeline
Index: qpdf-4.2.0/qpdf/qpdf.testcov
===================================================================
--- qpdf-4.2.0.orig/qpdf/qpdf.testcov	2013-07-10 12:59:45.339053938 -0400
+++ qpdf-4.2.0/qpdf/qpdf.testcov	2013-07-10 12:59:45.335053938 -0400
@@ -262,7 +262,6 @@
 QPDFObjectHandle EOF in inline image 0
 QPDFObjectHandle inline image token 0
 QPDF not caching overridden objstm object 0
-QPDFWriter original obj non-zero gen 0
 QPDF_optimization indirect outlines 0
 QPDF xref space 2
 qpdf pages range omitted at end 0
Index: qpdf-4.2.0/qpdf/qtest/qpdf/gen1.pdf
===================================================================
--- qpdf-4.2.0.orig/qpdf/qtest/qpdf/gen1.pdf	2013-07-10 12:59:45.339053938 -0400
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,79 +0,0 @@
-%PDF-1.3
-1 1 obj
-<<
-  /Type /Catalog
-  /Pages 2 1 R
->>
-endobj
-
-2 1 obj
-<<
-  /Type /Pages
-  /Kids [
-    3 1 R
-  ]
-  /Count 1
->>
-endobj
-
-3 1 obj
-<<
-  /Type /Page
-  /Parent 2 1 R
-  /MediaBox [0 0 612 792]
-  /Contents 4 1 R
-  /Resources <<
-    /ProcSet 5 1 R
-    /Font <<
-      /F1 6 1 R
-    >>
-  >>
->>
-endobj
-
-4 1 obj
-<<
-  /Length 44
->>
-stream
-BT
-  /F1 24 Tf
-  72 720 Td
-  (Potato) Tj
-ET
-endstream
-endobj
-
-5 1 obj
-[
-  /PDF
-  /Text
-]
-endobj
-
-6 1 obj
-<<
-  /Type /Font
-  /Subtype /Type1
-  /Name /F1
-  /BaseFont /Helvetica
-  /Encoding /WinAnsiEncoding
->>
-endobj
-
-xref
-0 7
-0000000000 65535 f 
-0000000009 00001 n 
-0000000063 00001 n 
-0000000135 00001 n 
-0000000307 00001 n 
-0000000403 00001 n 
-0000000438 00001 n 
-trailer <<
-  /Size 7
-  /Root 1 1 R
->>
-startxref
-556
-%%EOF
Index: qpdf-4.2.0/qpdf/qtest/qpdf.test
===================================================================
--- qpdf-4.2.0.orig/qpdf/qtest/qpdf.test	2013-07-10 12:59:45.339053938 -0400
+++ qpdf-4.2.0/qpdf/qtest/qpdf.test	2013-07-10 12:59:45.339053938 -0400
@@ -199,7 +199,7 @@
 show_ntests();
 # ----------
 $td->notify("--- Miscellaneous Tests ---");
-$n_tests += 67;
+$n_tests += 65;
 
 $td->runtest("qpdf version",
 	     {$td->COMMAND => "qpdf --version"},
@@ -501,14 +501,6 @@
               $td->EXIT_STATUS => 0},
              $td->NORMALIZE_NEWLINES);
 
-$td->runtest("generate object streams for gen > 0",
-             {$td->COMMAND => "qpdf --qdf --static-id" .
-		  " --object-streams=generate gen1.pdf a.pdf"},
-             {$td->STRING => "", $td->EXIT_STATUS => 0});
-$td->runtest("check file",
-             {$td->FILE => "a.pdf"},
-             {$td->FILE => "gen1.qdf"});
-
 # This file, from a user, is missing /ID in its trailer even though it
 # is encrypted and also has a space instead of a newline after its
 # xref keyword.  xpdf can open it, but Adobe reader can't.
@@ -1220,7 +1212,6 @@
      'lin-delete-and-reuse',	# linearized, then delete and reuse
      'object-stream',		# contains object streams
      'hybrid-xref',	        # contains both xref tables and streams
-     'gen1',                    # has objects with generation > 0
      'direct-outlines',         # /Outlines is a direct object
      @linearized_files,		# we should be able to relinearize
      );
